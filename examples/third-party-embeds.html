<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RedBlue Annotations: Third-Party Embeds</title>
    <link rel="stylesheet" href="index.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-light.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/xml.min.js"></script>
  </head>
  <body>
    <hgroup>
      <h1>RedBlue Annotations</h1>
      <h2>Third-Party Embeds</h2>
    </hgroup>
    <article>
      <h2>Hotspot Over YouTube Video</h2>

      <h4>Code</h4>
      <!-- <textarea id="code" rows="20" readonly="readonly"></textarea> -->
      <pre><code id="code" class="xml"></code></pre>

      <h4>Result</h4>
      <!-- XML -->
      <redblue-video id="redblue-youtube" aspect-ratio="16:9">
        <hvml
          xmlns="https://hypervideo.tech/hvml#"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:css="https://www.w3.org/TR/CSS/"
          xml:lang="en-US"
          hidden="hidden"
        >
          <video type="personal" xml:id="ep-23">
            <title>Overnight Dance Party at the Museum of Fine Arts Boston</title>
            <episode>23</episode>
            <recorded>2016-09-17</recorded>
            <description type="xhtml">
              <div xmlns="http://www.w3.org/1999/xhtml">
                <p>Full Facebook Live stream: http://hugh.today/2016-09-17/live</p>
                <p>#mfaNOW #mfaLateNites</p>
              </div>
            </description>
            <showing scope="release" type="internet" admission="private">
              <venue type="site">
                <entity site="https://www.youtube.com/">YouTube</entity>
                <uri>https://www.youtube.com/watch?v=nWdWq3hMwao</uri>
                <title>Overnight Dance Party at the Museum of Fine Arts Boston | Hugh’s Vlog | #mfaNOW #mfaLateNites</title>
              </venue>
            </showing>
            <presentation>
              <choice xml:id="full-stream">
                <name>Go to: <code style="font-family: inherit; font-weight: bold;">hugh.today/2016-09-17/live</code> for the full stream</name>
                <goto on="duration" xlink:actuate="onRequest" xlink:href="http://hugh.today/2016-09-17/live" width="70%" height="13%" css:font-size="calc(384 / 150 * 1vw)" css:font-family="'Noto Sans CJK JP', 'Noto Sans CJK', 'Noto Sans', sans-serif" css:white-space="nowrap" css:overflow="hidden">
                  <animate startTime="517.292107" endTime="518.872131" startX="14.9%" startY="-15%" endX="15%" endY="10%"></animate>
                  <animate startTime="523.373882" endTime="524.873404" startX="14.9%" startY="10%" endX="15%" endY="-15%"></animate>
                </goto>
              </choice>
            </presentation>
          </video>
        </hvml>
      </redblue-video>
    </article>
    <div id="scripts">
      <script id="redblue-video">
        'use strict';

        class RedBlueVideo extends HTMLElement {
          static get is() {
            return 'redblue-video';
          }

          static get template() {
            return `
              <template id="${RedBlueVideo.is}">
                <style>
                  :host {
                    position: relative;
                    display: block;
                    border: 1px solid black;
                  }

                  .redblue-player-wrapper {
                    position: relative;
                    overflow: hidden;
                  }

                  :host([aspect-ratio="16:9"]) .redblue-player-wrapper {
                    padding-bottom: 56.25%; /* 16:9 */
                    height: 0;
                  }

                  .redblue-player {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                  }

                  .redblue-content {}

                  .redblue-description {
                    overflow: auto;
                  }

                  .redblue-player {}

                  .redblue-fullscreen-context {
                    width: 100%;
                  }

                  .redblue-annotations {
                    width: 0;
                    height: 0;
                  }

                  .redblue-annotations__link {
                    position: absolute;
                    border: 1px solid transparent;
                    border-radius: 3px;
                    display: inline-flex;
                    text-align: center;
                    align-items: center;
                    justify-content: center;
                    color: transparent;
                    border: 3px solid rgba(139,157,195,1);
                  }

                  .redblue-fullscreen-button {
                    position: absolute;
                  }
                </style>
                <div class="redblue-content">
                  <div id="fullscreen-context" class="redblue-player-wrapper redblue-fullscreen-context">
                    <iframe id="embed" class="redblue-player"
                      src=""
                      frameborder="0"
                      allow="autoplay; encrypted-media"
                      allowfullscreen="allowfullscreen">
                    </iframe>
                    <button id="fullscreen-button" class="redblue-fullscreen-button">Toggle Fullscreen</button>
                    <nav id="annotations" class="redblue-annotations"></nav>
                  </div>
                  <div class="redblue-description">
                    <p>Full Facebook Live stream: http://hugh.today/2016-09-17/live</p>
                    <p>#mfaNOW #mfaLateNites</p>
                  </div>
                </div>
              </template>
            `;
          }

          constructor() {
            super();

            window.RedBlue = ( window.RedBlue || {} );

            this.setAttribute( 'class', 'redblue-video' );
            this.setAttribute( 'role', 'application' );

            this.$template = this.parseHTML( RedBlueVideo.template ).children[RedBlueVideo.is];
          } // constructor

          connectedCallback() {
            if ( !this.shadowRoot ) {
              this.attachShadow( { "mode": "open" } );
              this.shadowRoot.appendChild(
                document.importNode( this.$template.content, true )
              );
            }

            this.$   = {};
            this.$$  = this.shadowRoot.querySelector.bind( this.shadowRoot );
            this.$$$ = this.shadowRoot.querySelectorAll.bind( this.shadowRoot );
            this.$id = this.shadowRoot.getElementById.bind( this.shadowRoot );

            this.$.fullscreenButton = this.$id( 'fullscreen-button' );
            this.$.fullscreenContext = this.$id( 'fullscreen-context' );

            this.$.fullscreenButton.addEventListener( 'click', this.toggleFullscreen.bind( this ) );

            // The order here is important
            this.loadData();
            this.setUpYouTubeIframeAPI();
            this.annotations = this.getAnnotations();
            this._cssNamespacePrefix = this.getCSSNamespacePrefix();
            this.setupAnimations();
            this.createHotspots();
            this.timelineTriggers = this.getTimelineTriggers();
            this.highlightCode();

            this.embedParameters = '?rel=0&amp;showinfo=0&amp;start=517&amp;end=527&amp;enablejsapi=1&amp;controls=1&amp;modestbranding=1&amp;playsinline=1&amp;fs=0';
            this.$embed = this.shadowRoot.getElementById( 'embed' );
            this.$embed.src = this.getEmbedUri();
          } // connectedCallback

          // https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API
          toggleFullscreen( event ) {
            if ( document.fullscreenElement ) {
              document.exitFullscreen();
            } else if ( document.webkitFullscreenElement ) {
              document.webkitExitFullscreen();
            } else if ( document.mozFullScreenElement ) {
              document.mozCancelFullScreen();
            // -----------------------------------------------------------------
            } else if ( 'requestFullscreen' in this.$.fullscreenContext ) {
              this.$.fullscreenContext.requestFullscreen();
            } else if ( 'webkitRequestFullscreen' in this.$.fullscreenContext ) {
              this.$.fullscreenContext.webkitRequestFullscreen();
            } else if ( 'mozRequestFullScreen' in this.$.fullscreenContext ) {
              this.$.fullscreenContext.mozRequestFullScreen();
            }
          }

          getCSSNamespacePrefixFromXML() {
            for ( let i = 0; i < this.hvml.attributes.length; i++ ) {
              let attribute = this.hvml.attributes[i].nodeName;
              let namespaceAttribute = attribute.match( /^xmlns:([^=]+)/i );

              if (
                namespaceAttribute
                && ( this.hvml.getAttribute( attribute ).match( /https?:\/\/(www\.)?w3\.org\/TR\/CSS\/?/i ) )
              ) {
                return namespaceAttribute[1];
              }
            }

            return null;
          }

          getCSSNamespacePrefix() {
            if ( !this.hvml ) {
              return null;
            }

            const defaultPrefix = 'css';

            switch ( this._hvmlParser ) {
              case 'xml':
                return ( this.getCSSNamespacePrefixFromXML() || defaultPrefix );
              break;

              case 'json':
                return ( this.getCSSNamespacePrefixFromJSON() || defaultPrefix );
              break;
            }
          }

          setupAnimations() {
            const stylesheet = this.$$( 'style' ).sheet;
            const stylesheetRules = ( stylesheet.cssRules || stylesheet.rules );

            for ( let annotationIndex = 0; annotationIndex < this.annotations.length; annotationIndex++ ) {
              let annotation = this.annotations[annotationIndex];

              for ( let animateIndex = 0; animateIndex < this.annotations[annotationIndex].goto.animations.length; animateIndex++ ) {
                let animate = this.annotations[annotationIndex].goto.animations[animateIndex];

                if ( animateIndex === 0 ) {
                  let styleProperties = '';

                  for ( let attribute in annotation.goto ) {
                    if ( ( attribute === 'height' ) || ( attribute === 'width' ) ) {
                      styleProperties += `${attribute}: ${annotation.goto[attribute]};\n`;
                    } else {
                      let cssAttributeRegex = new RegExp( `^${this._cssNamespacePrefix}:([^=]+)`, 'i' );
                      let cssAttribute = attribute.match( cssAttributeRegex );

                      if ( cssAttribute ) {
                        styleProperties += `${cssAttribute[1]}: ${annotation.goto[attribute]};`;
                      }
                    }
                  }

                  stylesheet.insertRule( `
                    .redblue-annotations__link.redblue-annotations__link--${annotationIndex} {
                      ${styleProperties}
                      transition: ${animate.endtime - animate.starttime}s bottom linear;
                    }`, ( stylesheetRules.length )
                  );

                  stylesheet.insertRule( `
                    .redblue-annotations__link.redblue-annotations__link--${annotationIndex}-start {
                      left: ${animate.startx};
                      bottom: ${animate.starty};
                    }`, ( stylesheetRules.length )
                  );
                }

                stylesheet.insertRule( `
                  .redblue-annotations__link.redblue-annotations__link--${annotationIndex}-animate-${animateIndex}-end {
                    left: ${animate.startx};
                    bottom: ${animate.endy};
                  }`, ( stylesheetRules.length )
                );
              }
            } // for
          }

          parseHTML( string ) {
            return document.createRange().createContextualFragment( string );
          }

          highlightCode() {
            const $code = document.getElementById( 'code' );
            $code.textContent = document.getElementById( 'redblue-youtube' ).outerHTML.replace( /\n\s{8}/gi, '\n    ' ).replace( /\n\s*(<\/redblue-video>)/gi, '\n$1' );
            hljs.initHighlighting();
          }

          setUpYouTubeIframeAPI() {
            /*
              YouTube Player API:
              • Embedded players must have a viewport that is at least 200px by 200px.
              • If the player displays controls, it must be large enough to fully
                display the controls without shrinking the viewport below the minimum size.
              • We recommend 16:9 players be at least 480 pixels wide and 270 pixels tall.
            */
            const tag = document.createElement( 'script' );
            tag.id = 'youtube-iframe-api';
            tag.src = 'https://www.youtube.com/iframe_api';
            tag.async = true;
            const firstScriptTag = document.getElementsByTagName( 'script' )[0];
            firstScriptTag.parentNode.insertBefore( tag, firstScriptTag );

            window.onYouTubeIframeAPIReady = () => {
              this.player = new YT.Player( this.$id( 'embed' ), {
                "events": {
                  "onReady": this.onPlayerReady.bind( this ),
                  "onStateChange": this.onStateChange.bind( this )
                }
              } );

              document.addEventListener( 'keydown', ( event ) => {
                switch ( event.key ) {
                  case 'm':
                    console.log( this.player.getCurrentTime() );
                  break;
                }
              } );
            };
          }

          onPlayerReady( event ) {
            this.$id( 'embed' ).style.borderColor = '#FF6D00';
            this.player.mute();
          }

          onStateChange() {
            requestAnimationFrame( this.updatePlayback.bind( this ) );
          }

          addLeadingZeroes( number ) {
            return number.toString().padStart( 2, '0' );
          }

          // http://aphall.com/2014/03/animate-video-sync/
          // the youtube API sends no events at all on seek,
          // so unfortunately we have to poll the video if
          // we want to react to when the user seeks manually. :(
          updatePlayback() {
            if ( this.player && this.player.getCurrentTime ) {
              // Returns the elapsed time in seconds since the video started playing
              const time = this.player.getCurrentTime(); /* * 1000*/
              const state = this.player.getPlayerState();

              // https://stackoverflow.com/a/9882349/214325
              if ( state == YT.PlayerState.PLAYING ) {
                for ( let startTime in this.timelineTriggers ) {
                  startTime  = parseFloat( startTime );
                  let trigger = this.timelineTriggers[startTime];
                  let endTime = trigger.endtime;
                  let totalAnimations = this.annotations[trigger.annotationIndex].goto.animations.length;

                  if ( ( time >= startTime ) && ( time <= endTime ) && !trigger.$ui.classList.contains( trigger.endClass ) ) {
                    console.log( '---------' );
                    let drift = Math.abs( time - trigger.starttime );

                    if ( trigger.animateIndex == 0 ) {
                      trigger.$ui.classList.remove( trigger.startClass );
                    } else {
                      trigger.$ui.classList.remove( trigger.previousEndClass );
                    }

                    trigger.$ui.classList.add( trigger.endClass );

                    console.log( `Starting annotation #${trigger.annotationIndex}, transition #${trigger.animateIndex} at: `, time );
                    console.log( 'Should be: ', trigger.starttime );
                    console.log( 'Drift: ', drift );

                    if ( trigger.animateIndex == ( totalAnimations - 1 ) ) {
                      let transitionDuration = parseFloat( getComputedStyle( trigger.$ui ).getPropertyValue( 'transition-duration' ).slice( 0, -1 ) );

                      console.log( '---------' );
                      console.log( 'No more animations' );
                      console.log( 'this.annotations', this.annotations );

                      setTimeout( () => {
                        console.log( 'timeout' );

                        // Remove all previous animate classes
                        while ( totalAnimations-- ) {
                          trigger.$ui.classList.remove(
                            trigger.endClass.replace( /animate-[0-9]+-/, `animate-${totalAnimations}-` )
                          );
                        }

                        trigger.$ui.classList.add( trigger.startClass );
                      }, transitionDuration * 1000 );
                    }
                  }
                }
              } else {
                // console.log( 'not playing' );
              }
            }

            requestAnimationFrame( this.updatePlayback.bind( this ) );
          }

          loadData() {
            for ( let i = 0; i < this.children.length; i++ ) {
              let child = this.children[i];

              switch ( child.nodeName.toLowerCase() ) {
                case 'hvml':
                  this.hvml = child;
                  this._hvmlParser = 'xml';
                  return;
                break;

                case 'script':
                  if ( child.hasAttribute( 'type' ) && ( child.type === 'application/ld+json' ) ) {
                    this.hvml = child;
                    this._hvmlParser = 'json';
                    return;
                  }
                break;
              } // switch
            } // for
          }

          find( xpathExpression,  ) {
            return document.evaluate(
              xpathExpression,
              this.hvml, // contextNode
              function ( prefix ) {
                const ns = {
                  "hvml": "https://hypervideo.tech/hvml#",
                  "html": "http://www.w3.org/1999/xhtml"
                };

                return ( ns[prefix] || ns.html );
              }, // namespaceResolver
              // XPathResult.ANY_TYPE, // resultType
              XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
              null // result
            )
          }

          getEmbedUriFromXML() {
            /*
              <showing scope="release" type="internet" admission="private">
                <venue type="site">
                  <entity site="https://www.youtube.com/">YouTube</entity>
                  <uri>https://www.youtube.com/watch?v=nWdWq3hMwao</uri>
                  <title>Overnight Dance Party at the Museum of Fine Arts Boston | Hugh’s Vlog | #mfaNOW #mfaLateNites</title>
                </venue>
              </showing>
            */
            // https://www.youtube.com/embed/nWdWq3hMwao?rel=0&amp;showinfo=0&amp;start=517&amp;end=527&amp;enablejsapi=1&amp;controls=0&amp;modestbranding=1
            try {
              let youtubeUrl = this.find( `.//showing[@scope="release"]/venue[@type="site"]/uri[contains(., 'https://www.youtube.com/watch?v=')]/text()` ).snapshotItem(0);

              if ( youtubeUrl ) {
                return youtubeUrl.textContent.replace( /https:\/\/www\.youtube\.com\/watch\?v=([^&?]+)/i, `https://www.youtube.com/embed/$1${this.embedParameters}` );
              }

              throw 'No YouTube URL found';
            } catch ( error ) {
              console.error( error );
            }
          }

          getEmbedUriFromJSON() {}

          getEmbedUri() {
            switch ( this._hvmlParser ) {
              case 'xml':
                return this.getEmbedUriFromXML();
              break;

              case 'json':
                return this.getEmbedUriFromJSON();
              break;
            }
          }

          createHotspots() {
            for ( let i = 0; i < this.annotations.length; i++ ) {
              let annotation = this.annotations[i];

              this.createHotspot( annotation, i );
            }
          }

          createHotspot( annotation, index ) {
            let $annotation = this.parseHTML(
              `<a
                id="annotation-${index}"
                class="redblue-annotations__link redblue-annotations__link--${index} redblue-annotations__link--${index}-start"
                href="${annotation.goto['xlink:href']}"
                target="_blank"
               >
                 <span>${annotation.name}</span>
              </a>`
            );

            this.$id( 'annotations' ).appendChild( $annotation );
          }

          mapAttributeToKeyValuePair( attribute ) {
            const object = {};
            object[attribute.nodeName] = attribute.nodeValue;
            return object;
          }

          flattenKeyValuePairs( accumulator, keyValuePair ) {
            const key = Object.keys( keyValuePair )[0];
            const value = keyValuePair[key];

            accumulator[key] = value;

            return accumulator;
          }

          nodeAttributesToJSON( attributes ) {
            return Array.from( attributes ).map( this.mapAttributeToKeyValuePair ).reduce( this.flattenKeyValuePairs, {} );
          }

          getAnnotationsFromJSON() {}

          getAnnotationsFromXML() {
            const annotations = [];
            const $presentation = this.find( `.//presentation[1]` ).snapshotItem(0);

            for ( let i = 0, length = $presentation.children.length; i < length; i++ ) {
              let child = $presentation.children[i];
              let nodeName = child.nodeName.toLowerCase();

              switch ( nodeName ) {
                case 'choice':
                  let choice = {};

                  for ( let i = 0; i < child.children.length; i++ ) {
                    let grandchild = child.children[i];
                    let nodeName = grandchild.nodeName.toLowerCase();

                    switch ( nodeName ) {
                      case 'name':
                        choice[nodeName] = ( grandchild.nodeValue || grandchild.innerHTML );
                      break;

                      case 'goto':
                        choice[nodeName] = this.nodeAttributesToJSON( grandchild.attributes );

                        choice[nodeName].animations = Array.from( grandchild.children ).filter( ( gotoChild ) => {
                          const nodeName = gotoChild.nodeName.toLowerCase();

                          switch ( nodeName ) {
                            case 'animate':
                              return true;
                          }
                        } ).map( ( animateElement ) => {
                          return this.nodeAttributesToJSON( animateElement.attributes );
                        } );
                      break;
                    }
                  }

                  choice.type = nodeName;

                  console.log( 'choice', choice );
                  annotations.push( choice );
                break;

                /*
                  <goto
                    xlink:actuate="onRequest"
                    on="duration | durationStart | durationEnd"
                    start="517"
                    end="527"
                    xlink:href="http://hugh.today/2016-09-17/live"
                  />
                */
                case 'goto':
                // break;
                case 'playlistAction':
                // break;
                case 'choices':
                // break;
                case 'media':
                // break;
                default:
                  console.log( 'not `choice`', nodeName );
              }
            }

            return annotations;
          }

          getAnnotations() {
            if ( !this.hvml ) {
              return null;
            }

            switch ( this._hvmlParser ) {
              case 'xml':
                return this.getAnnotationsFromXML();
              break;

              case 'json':
                return this.getAnnotationsFromJSON();
              break;
            } // switch
          } // getAnnotations

          getTimelineTriggers() {
            if ( !this.annotations ) {
              return null;
            }

            let triggers = {};

            for ( let annotationIndex = 0; annotationIndex  < this.annotations.length; annotationIndex++ ) {
              let annotation = this.annotations[annotationIndex ];

              for ( let animateIndex = 0, totalAnimations = annotation.goto.animations.length; animateIndex < totalAnimations; animateIndex++ ) {
                let animate = annotation.goto.animations[animateIndex];

                triggers[animate.starttime] = {
                  ...animate,
                  annotationIndex,
                  animateIndex,
                  "name": annotation.name,
                  "$ui": this.$id( `annotation-${annotationIndex}` ),
                  "startClass": `redblue-annotations__link--${annotationIndex}-start`,
                  "endClass": `redblue-annotations__link--${annotationIndex}-animate-${animateIndex}-end`
                };

                if ( animateIndex > 0 ) {
                  triggers[animate.starttime].previousEndClass = `redblue-annotations__link--animate-${animateIndex - 1}-end`;
                }
              }
            }

            return triggers;
          }
        }

        customElements.define( RedBlueVideo.is, RedBlueVideo );
      </script>
    </div>
  </body>
</html>
<!-- <script type="application/ld+json">
  {
    "@context": "https://hypervideo.tech/hvml#",
    "@type": "video"
  }
</script> -->
<!--
  Design considerations:
  • Does `playlist` make sense to mark up annotations *within* a video,
    or is it only for “meta-videos”, i.e. those that embed other videos?
  • `playlist type="nonlinear"` is only required if sibling actions
    (`goto`, `playlistAction`, `media`) are not guranteed to execute.
  • `playlist type="linear"` means that all actions are guaranteed to
    execute provided the user encounters their triggers (typically duration)
  • If a video only has one action, is `playlist` required?
-->
